import asyncio
import os
from pyrogram import Client, filters
from pyrogram.errors import AuthKeyUnregistered, FloodWait, RPCError
from datetime import datetime
from zoneinfo import ZoneInfo
import logging
from flask import Flask, request, render_template_string
import requests # برای مکانیزم ضد خواب
from waitress import serve # برای اجرای ایمن Flask در سرورهای ابری

# تنظیمات اولیه لاگینگ
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# =======================================================
# ⚠️ تنظیمات حساب کاربری و حالت (Global State)
# =======================================================

# توصیه می شود این مقادیر را به عنوان Secrets در Replit/Render تنظیم کنید.
API_ID = int(os.environ.get("API_ID", 28190856))
API_HASH = os.environ.get("API_HASH", "6b9b5309c2a211b526c6ddad6eabb521")
SESSION_NAME = "my_account_web"

# متن پاسخ خودکار در غیاب شما
AUTO_REPLY_MESSAGE = "سلام، آنلاین نیستم. پیام شما را دریافت کردم. در حال حاضر خارج از دسترس هستم، اما در اولین فرصت ممکن، پاسخ خواهم داد."

# تعریف منطقه زمانی تهران
TEHRAN_TIMEZONE = ZoneInfo("Asia/Tehran")

# متغیرهای حالت سراسری
app_flask = Flask(__name__)
app_client = None 
bot_running_event = asyncio.Event()

# =======================================================
# بخش ۱: مدیریت فونت و ساعت زنده (Live Clock)
# =======================================================

def stylize_time(time_str: str) -> str:
    """تبدیل ارقام ساعت به فونت شیک Math Monospace."""
    conversion_map = {
        '0': '𝟶', '1': '𝟷', '2': '𝟸', '3': '𝟹', '4': '𝟺',
        '5': '𝟻', '6': '𝟼', '7': '𝟽', '8': '𝟾', '9': '𝟿',
        ':': ':'
    }
    return ''.join(conversion_map.get(char, char) for char in time_str)

async def update_name():
    """حلقه بی‌پایان برای به‌روزرسانی نام با ساعت زنده. بسیار مقاوم در برابر قطعی شبکه و خطاها."""
    first_name = "𝓎𝑒 𝒶𝓂𝒾𝓇"
    
    global app_client
    if app_client is None:
        logger.error("❌ update_name called but app_client is not initialized.")
        return

    while True:
        # --- منطق همگام‌سازی (اولین کار در حلقه، برای اطمینان از دقت) ---
        now = datetime.now()
        seconds_into_minute = now.second + now.microsecond / 1_000_000
        sleep_seconds = 60 - seconds_into_minute
        
        if sleep_seconds < 0.5:
            sleep_seconds += 60
        
        await asyncio.sleep(sleep_seconds)
        
        try:
            # --- منطق اصلی به‌روزرسانی ---
            tehran_time = datetime.now(TEHRAN_TIMEZONE)
            current_time_str = tehran_time.strftime("%H:%M")
            stylized_time_str = stylize_time(current_time_str)
            name_with_clock = f"{first_name} {stylized_time_str}"
            
            # به‌روزرسانی نام
            await app_client.update_profile(first_name=name_with_clock)
            logger.info(f"✅ Live Clock: Updated name to: {name_with_clock}")
        
        except FloodWait as e:
            logger.warning(f"🛑 Live Clock: Rate Limit hit. Waiting for {e.value} seconds.")
            await asyncio.sleep(e.value)
            
        except (RPCError, asyncio.TimeoutError):
            logger.error("⚠️ Live Clock: Connection error or API call timed out. Waiting 10 seconds before next attempt.")
            await asyncio.sleep(10)
            
        except Exception as e:
            logger.error(f"❌ Live Clock: Unhandled Error during name update. Attempting to recover: {e}")
            await asyncio.sleep(5)

# =======================================================
# بخش ۲: پاسخ خودکار (Auto-Reply)
# =======================================================

def register_handlers(client: Client):
    @client.on_message(filters.private & ~filters.me)
    async def auto_reply(client: Client, message):
        """فقط به پیام‌های خصوصی که از طرف خود کاربر نیستند، پاسخ می‌دهد."""
        try:
            if message.from_user and not message.from_user.is_bot:
                await message.reply_text(AUTO_REPLY_MESSAGE)
                logger.info(f"💬 Auto-Reply: SUCCESS sent to {message.from_user.first_name}")
        except Exception as e:
            logger.error(f"❌ Auto-Reply: Failed to send to {message.chat.id}: {e}")

# =======================================================
# بخش ۳: مکانیزم ضد خواب (Anti-Sleep for Render/Replit)
# =======================================================

async def keep_alive(anti_sleep_url: str):
    """
    هر 5 دقیقه یک بار به آدرس URL خود پروژه درخواست می فرستد تا از خوابیدن سرور جلوگیری کند.
    """
    if anti_sleep_url == "http://127.0.0.1:5000":
        logger.warning("❌ ANTI-SLEEP WARNING: The URL is set to localhost. You MUST set the 'RENDER_EXTERNAL_URL' Secret in Replit with your public URL (e.g., https://selfprofile-3.amirpitmax3.repl.co) for 24/7 function.")
    else:
        logger.info(f"🔋 Anti-Sleep activated. Pinging URL: {anti_sleep_url} every 5 minutes.")

    while True:
        await asyncio.sleep(300) # 5 minutes
        try:
            if anti_sleep_url != "http://127.0.0.1:5000":
                # از یک timeout کوتاه استفاده می کنیم تا منتظر پاسخ کامل نمانیم
                requests.get(anti_sleep_url, timeout=10)
                logger.debug("✨ Keep Alive: Ping successful.")
        except Exception as e:
            logger.warning(f"❌ Keep Alive: Failed to ping URL {anti_sleep_url}. Error: {e}")

# =======================================================
# بخش ۴: رابط وب (Flask Web Interface)
# =======================================================

# قالب HTML ساده و زیبا با Tailwind CSS برای فرم ورود
WEB_FORM_HTML = """
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>فعال‌سازی سلف‌بات Clock</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');
        body { font-family: 'Vazirmatn', sans-serif; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="max-w-md w-full bg-white p-8 rounded-xl shadow-2xl border border-blue-200">
        <h1 class="text-3xl font-bold text-center text-blue-700 mb-6">⏰ فعال‌سازی ربات ساعت زنده</h1>
        <p class="text-gray-600 text-center mb-8">لطفاً Session String معتبر خود را وارد کنید تا ربات فعال شود. این اطلاعات هرگز ذخیره نمی‌شوند.</p>
        
        {% if status %}
            <div class="p-4 mb-6 rounded-lg font-medium text-center 
            {% if 'فعال شد' in status %} bg-green-100 text-green-700 
            {% elif 'منتظر' in status %} bg-yellow-100 text-yellow-700
            {% else %} bg-red-100 text-red-700 
            {% endif %}">
                وضعیت: {{ status }}
            </div>
        {% endif %}

        <form method="POST" action="/activate" class="space-y-4">
            <div>
                <label for="session_string" class="block text-sm font-medium text-gray-700">Session String</label>
                <textarea id="session_string" name="session_string" rows="3" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500"></textarea>
            </div>
            
            <button type="submit" class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out">
                فعال‌سازی و شروع ربات
            </button>
        </form>
        
        <p class="text-xs text-gray-400 text-center mt-6">
            <a href="https://replit.com/@amirpitmax3/selfprofile-3" target="_blank" class="hover:underline">پروژه Replit شما</a>
        </p>
    </div>
</body>
</html>
"""

# مسیر اصلی وب‌سایت
@app_flask.route('/', methods=['GET'])
def index():
    status = "منتظر ورود سشن"
    if bot_running_event.is_set():
        status = "ربات فعال شد و در حال به‌روزرسانی ساعت می‌باشد."
    return render_template_string(WEB_FORM_HTML, status=status)

# مسیر فعال‌سازی (پس از سابمیت فرم)
@app_flask.route('/activate', methods=['POST'])
def activate():
    session_string = request.form.get('session_string', '').strip()
    
    if not session_string:
        return render_template_string(WEB_FORM_HTML, status="خطا: Session String نمی‌تواند خالی باشد."), 400

    # اجرای وظایف ربات در حلقه Asyncio اصلی
    flask_loop = asyncio.get_event_loop()
    # اگر قبلاً ربات اجرا شده باشد، ابتدا اتصال را قطع می‌کنیم.
    if app_client and bot_running_event.is_set():
        flask_loop.run_until_complete(app_client.stop())
        bot_running_event.clear()
        logger.info("Previous bot instance stopped.")

    flask_loop.create_task(start_bot_tasks(session_string))
    
    return render_template_string(WEB_FORM_HTML, status="فعال شد! ساعت زنده و پاسخ خودکار در پس‌زمینه شروع به کار کردند. لطفاً کنسول Replit را بررسی کنید."), 200

# =======================================================
# بخش ۵: اجرای هسته (Core Execution)
# =======================================================

async def start_bot_tasks(session_string):
    """ربات Pyrogram را با Session String جدید مقداردهی اولیه و وظایف را شروع می کند."""
    global app_client
    
    # 1. مقداردهی اولیه کلاینت با سشن استرینگ جدید
    try:
        app_client = Client(
            name=SESSION_NAME, 
            api_id=API_ID, 
            api_hash=API_HASH, 
            session_string=session_string 
        )
        logger.info("Initializing Pyrogram Client...")

        # 2. اتصال
        await app_client.start()
        logger.info("✅ Client successfully connected and authenticated!")
        
    except AuthKeyUnregistered:
        logger.critical("🔴 FATAL ERROR: Invalid or expired Session String. Please check your session and try again.")
        app_client = None
        return
    except Exception as e:
        logger.critical(f"🔴 FATAL ERROR during client start: {e}")
        app_client = None
        return

    # 3. ثبت هندلرها
    register_handlers(app_client)
    logger.info("✅ Auto-Reply handler registered.")

    # 4. اجرای ساعت و ضد خواب
    asyncio.create_task(update_name())
    logger.info("✅ Live Clock started as a background task.")

    # Anti-Sleep: استفاده از متغیر محیطی که آدرس عمومی پروژه را نگه می‌دارد.
    anti_sleep_url = os.environ.get('RENDER_EXTERNAL_URL') or "http://127.0.0.1:5000"
    asyncio.create_task(keep_alive(anti_sleep_url))

    bot_running_event.set() # تنظیم فلگ برای نشان دادن اجرای ربات


def run_pyrogram_and_flask():
    """شروع وظایف Pyrogram و Flask در حلقه async واحد."""
    port = int(os.environ.get("PORT", 5000))
    host = '0.0.0.0' 
    
    logger.info(f"🌐 Flask Web Server starting on {host}:{port}")

    # از تابع serve کتابخانه Waitress برای اجرای Flask در یک Thread جداگانه استفاده می کنیم
    loop = asyncio.get_event_loop()
    loop.run_in_executor(None, serve, app_flask, host=host, port=port)
    
    try:
        loop.run_forever()
    except KeyboardInterrupt:
        logger.info("\nServer and Bot stopped by user (Ctrl+C).")
    finally:
        # کلاینت فقط در صورت وجود و فعال بودن متوقف می شود
        if app_client:
            loop.run_until_complete(app_client.stop())
        logger.info("Cleanup complete. Goodbye!")

if __name__ == "__main__":
    # اگر فایل سشن وجود داشته باشد، به صورت خودکار سعی در لاگین می‌کند (برای محیط‌های لوکال)
    if os.path.exists(f"{SESSION_NAME}.session"):
        logger.info("Session file found. Attempting to start the bot automatically...")
        asyncio.run(start_bot_tasks(None)) 
        
    # حالا Flask و Pyrogram را همزمان اجرا کن
    run_pyrogram_and_flask()
