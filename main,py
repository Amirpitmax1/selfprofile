import asyncio
import os
from pyrogram import Client, filters
from pyrogram.errors import AuthKeyUnregistered, FloodWait, RPCError
from datetime import datetime
from zoneinfo import ZoneInfo
import logging
from flask import Flask, request, redirect, url_for, render_template_string
import requests # برای مکانیزم ضد خواب

# تنظیمات اولیه لاگینگ
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# =======================================================
# ⚠️ تنظیمات حساب کاربری و حالت (Global State)
# =======================================================

# Your credentials (API ID and Hash are necessary for Pyrogram client initialization)
API_ID = 28190856
API_HASH = "6b9b5309c2a211b526c6ddad6eabb521"
SESSION_NAME = "my_account_web"

# متن پاسخ خودکار در غیاب شما
AUTO_REPLY_MESSAGE = "سلام، آنلاین نیستم. پیام شما را دریافت کردم. در حال حاضر خارج از دسترس هستم، اما در اولین فرصت ممکن، پاسخ خواهم داد."

# تعریف منطقه زمانی تهران
TEHRAN_TIMEZONE = ZoneInfo("Asia/Tehran")

# متغیرهای حالت سراسری
app_flask = Flask(__name__)
# از app_client برای نگهداری نمونه فعال Pyrogram استفاده می شود
app_client = None 
bot_running_event = asyncio.Event()

# =======================================================
# بخش ۱: مدیریت فونت و ساعت زنده (Live Clock)
# =======================================================

def stylize_time(time_str: str) -> str:
    """تبدیل ارقام ساعت به فونت شیک Math Monospace."""
    conversion_map = {
        '0': '𝟶', '1': '𝟷', '2': '𝟸', '3': '𝟹', '4': '𝟺',
        '5': '𝟻', '6': '𝟼', '7': '𝟽', '8': '𝟾', '9': '𝟿',
        ':': ':'
    }
    return ''.join(conversion_map.get(char, char) for char in time_str)

async def update_name():
    """حلقه بی‌پایان برای به‌روزرسانی نام با ساعت زنده. بسیار مقاوم در برابر قطعی شبکه و خطاها."""
    first_name = "𝓎𝑒 𝒶𝓂𝒾𝓇"
    
    # اطمینان از دسترسی به کلاینت فعال
    global app_client
    if app_client is None:
        logger.error("❌ update_name called but app_client is not initialized.")
        return

    while True:
        # --- منطق همگام‌سازی (اولین کار در حلقه، برای اطمینان از دقت) ---
        now = datetime.now()
        seconds_into_minute = now.second + now.microsecond / 1_000_000
        sleep_seconds = 60 - seconds_into_minute
        
        if sleep_seconds < 0.5:
            sleep_seconds += 60
        
        await asyncio.sleep(sleep_seconds)
        
        try:
            # --- منطق اصلی به‌روزرسانی ---
            tehran_time = datetime.now(TEHRAN_TIMEZONE)
            current_time_str = tehran_time.strftime("%H:%M")
            stylized_time_str = stylize_time(current_time_str)
            name_with_clock = f"{first_name} {stylized_time_str}"
            
            # به‌روزرسانی نام
            await app_client.update_profile(first_name=name_with_clock)
            logger.info(f"✅ Live Clock: Updated name to: {name_with_clock}")
        
        except FloodWait as e:
            logger.warning(f"🛑 Live Clock: Rate Limit hit. Waiting for {e.value} seconds.")
            await asyncio.sleep(e.value)
            
        except (RPCError, asyncio.TimeoutError):
            logger.error("⚠️ Live Clock: Connection error or API call timed out. Waiting 10 seconds before next attempt.")
            await asyncio.sleep(10)
            
        except Exception as e:
            logger.error(f"❌ Live Clock: Unhandled Error during name update. Attempting to recover: {e}")
            await asyncio.sleep(5)

# =======================================================
# بخش ۲: پاسخ خودکار (Auto-Reply)
# =======================================================

# این دکوراتور باید بعد از مقداردهی اولیه app_client به آن متصل شود.
# ما از یک متغیر جهانی برای این کار استفاده می کنیم.
def register_handlers(client: Client):
    @client.on_message(filters.private & ~filters.me)
    async def auto_reply(client: Client, message):
        """فقط به پیام‌های خصوصی که از طرف خود کاربر نیستند، پاسخ می‌دهد."""
        try:
            if message.from_user and not message.from_user.is_bot:
                await message.reply_text(AUTO_REPLY_MESSAGE)
                logger.info(f"💬 Auto-Reply: SUCCESS sent to {message.from_user.first_name}")
        except Exception as e:
            logger.error(f"❌ Auto-Reply: Failed to send to {message.chat.id}: {e}")

# =======================================================
# بخش ۳: مکانیزم ضد خواب (Anti-Sleep for Render)
# =======================================================

async def keep_alive(render_url: str):
    """
    هر 5 دقیقه یک بار به آدرس URL خود پروژه درخواست می فرستد تا از خوابیدن سرور جلوگیری کند.
    """
    logger.info(f"🔋 Anti-Sleep activated. Pinging URL: {render_url} every 5 minutes.")
    while True:
        await asyncio.sleep(300) # 5 minutes
        try:
            # استفاده از requests برای ارسال درخواست HTTP
            requests.get(render_url, timeout=10)
            logger.debug("✨ Keep Alive: Ping successful.")
        except Exception as e:
            logger.warning(f"❌ Keep Alive: Failed to ping URL {render_url}. Error: {e}")

# =======================================================
# بخش ۴: رابط وب (Flask Web Interface)
# =======================================================

# قالب HTML ساده و زیبا با Tailwind CSS برای فرم ورود
WEB_FORM_HTML = """
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>فعال‌سازی سلف‌بات Clock</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');
        body { font-family: 'Vazirmatn', sans-serif; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="max-w-md w-full bg-white p-8 rounded-xl shadow-2xl border border-blue-200">
        <h1 class="text-3xl font-bold text-center text-blue-700 mb-6">⏰ فعال‌سازی ربات ساعت زنده</h1>
        <p class="text-gray-600 text-center mb-8">لطفاً Session String معتبر خود را وارد کنید تا ربات فعال شود. این اطلاعات هرگز ذخیره نمی‌شوند.</p>
        
        {% if status %}
            <div class="p-4 mb-6 rounded-lg font-medium text-center 
            {% if status == 'فعال شد' %} bg-green-100 text-green-700 
            {% elif status == 'منتظر' %} bg-yellow-100 text-yellow-700
            {% else %} bg-red-100 text-red-700 
            {% endif %}">
                وضعیت: {{ status }}
            </div>
        {% endif %}

        <form method="POST" action="{{ url_for('activate') }}" class="space-y-4">
            <div>
                <label for="session_string" class="block text-sm font-medium text-gray-700">Session String</label>
                <textarea id="session_string" name="session_string" rows="3" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500"></textarea>
            </div>
            
            <button type="submit" class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out">
                فعال‌سازی و شروع ربات
            </button>
        </form>
        
        <p class="text-xs text-gray-400 text-center mt-6">
            <a href="https://t.me/ye_amir" target="_blank" class="hover:underline">نیاز به Session String دارید؟</a>
        </p>
    </div>
</body>
</html>
"""

# مسیر اصلی وب‌سایت
@app_flask.route('/', methods=['GET'])
def index():
    status = "منتظر ورود سشن"
    if bot_running_event.is_set():
        status = "ربات فعال است و در حال به‌روزرسانی ساعت می‌باشد."
    return render_template_string(WEB_FORM_HTML, status=status)

# مسیر فعال‌سازی (پس از سابمیت فرم)
@app_flask.route('/activate', methods=['POST'])
def activate():
    session_string = request.form.get('session_string', '').strip()
    
    if not session_string:
        return render_template_string(WEB_FORM_HTML, status="خطا: Session String نمی‌تواند خالی باشد."), 400

    # اگر قبلاً ربات در حال اجراست، اول آن را متوقف کن
    global app_client
    if app_client is not None and bot_running_event.is_set():
        # متوقف کردن سرویس قبلی (اختیاری اما توصیه می شود)
        pass # در این معماری، Pyrogram در حال اجرا در یک Thread جداگانه است و نیازی به توقف اجباری نیست.

    # شروع وظایف ربات در یک Thread جداگانه
    # از آنجایی که Flask از Threading استفاده می کند، باید از یک executor برای اجرای وظایف asyncio استفاده کنیم
    flask_loop = asyncio.get_event_loop()
    flask_loop.create_task(start_bot_tasks(session_string))
    
    return render_template_string(WEB_FORM_HTML, status="فعال شد! ساعت زنده و پاسخ خودکار در پس‌زمینه شروع به کار کردند."), 200

# =======================================================
# بخش ۵: اجرای هسته (Core Execution)
# =======================================================

async def start_bot_tasks(session_string):
    """ربات Pyrogram را با Session String جدید مقداردهی اولیه و وظایف را شروع می کند."""
    global app_client
    
    # 1. مقداردهی اولیه کلاینت با سشن استرینگ جدید
    try:
        app_client = Client(
            name=SESSION_NAME, 
            api_id=API_ID, 
            api_hash=API_HASH, 
            session_string=session_string
        )
        logger.info("Initializing Pyrogram Client...")

        # 2. اتصال
        await app_client.start()
        logger.info("✅ Client successfully connected and authenticated!")
        
    except AuthKeyUnregistered:
        logger.critical("🔴 FATAL ERROR: Invalid or expired Session String. Please check your session and try again.")
        app_client = None
        return
    except Exception as e:
        logger.critical(f"🔴 FATAL ERROR during client start: {e}")
        app_client = None
        return

    # 3. ثبت هندلرها
    register_handlers(app_client)
    logger.info("✅ Auto-Reply handler registered.")

    # 4. اجرای ساعت و ضد خواب
    asyncio.create_task(update_name())
    logger.info("✅ Live Clock started as a background task.")

    # Anti-Sleep (فقط اگر در محیط Render یا مشابه هستیم)
    render_url = os.environ.get('RENDER_EXTERNAL_URL') or "http://127.0.0.1:5000"
    asyncio.create_task(keep_alive(render_url))
    logger.info("✅ Anti-Sleep task initiated.")

    bot_running_event.set() # تنظیم فلگ برای نشان دادن اجرای ربات
    
    # اینجا نیازی به await Event().wait() نیست چون Flask پروسه اصلی را نگه می دارد.


def run_pyrogram_and_flask():
    """شروع وظایف Pyrogram و Flask در حلقه async واحد."""
    # Render پورت را به عنوان متغیر محیطی PORT ارسال می کند
    port = int(os.environ.get("PORT", 5000))
    host = '0.0.0.0' # برای رندر ضروری است
    
    # از سرویس های Flask برای اجرای در حلقه asyncio استفاده می کنیم.
    # به جای app_flask.run() که مسدود کننده است، از ابزار کمکی استفاده می کنیم.
    from waitress import serve
    logger.info(f"🌐 Flask Web Server starting on {host}:{port}")

    # از آنجایی که Pyrogram و Flask هر دو در حال اجرا هستند، از یک Executor برای Flask استفاده می کنیم
    # این تابع Flask را در یک Thread جداگانه اجرا می کند و اجازه می دهد asyncio کار کند.
    # توجه: در محیط رندر نیاز به Waitress یا Gunicorn دارید، ما از Waitress برای شبیه‌سازی استفاده می‌کنیم.
    
    # Start the Flask server using a thread pool executor, allowing the asyncio loop to run
    loop = asyncio.get_event_loop()
    loop.run_in_executor(None, serve, app_flask, host=host, port=port)
    
    try:
        loop.run_forever()
    except KeyboardInterrupt:
        logger.info("\nServer and Bot stopped by user (Ctrl+C).")
    finally:
        if app_client:
            loop.run_until_complete(app_client.stop())
        logger.info("Cleanup complete. Goodbye!")

if __name__ == "__main__":
    # اگر در محیط لوکال اجرا می کنید، به طور خودکار لاگین کنید (اگر فایل سشن وجود دارد)
    if os.path.exists(f"{SESSION_NAME}.session"):
        logger.info("Session file found. Attempting to start the bot automatically...")
        asyncio.run(start_bot_tasks(None)) # با None می تواند سشن را از فایل بخواند
        
    # حالا Flask و Pyrogram را همزمان اجرا کن
    run_pyrogram_and_flask()
