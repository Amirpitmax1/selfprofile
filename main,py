import asyncio
from pyrogram import Client, filters
from pyrogram.errors import AuthKeyUnregistered, FloodWait
from datetime import datetime
from zoneinfo import ZoneInfo
from flask import Flask
from threading import Thread

# =======================================================
# بخش ۰: وب سرور برای روشن نگه‌داشتن ربات در Repl.it
# =======================================================

# یک وب سرور ساده با Flask ایجاد می‌کنیم
# این سرور باعث می‌شود Repl.it فکر کند که برنامه شما همیشه فعال است
app_flask = Flask('')

@app_flask.route('/')
def home():
    # هر متنی اینجا باشد کافی است
    return "I am alive!"

def run_flask():
  # سرور را روی هاست و پورت استاندارد Repl.it اجرا می‌کند
  app_flask.run(host='0.0.0.0', port=8080)

def keep_alive():
    # سرور را در یک ترد (thread) جداگانه اجرا می‌کند تا با ربات تداخل نداشته باشد
    t = Thread(target=run_flask)
    t.start()

# =======================================================
# ⚠️ تنظیمات حساب کاربری (Account Configuration)
# =======================================================

# Your credentials
API_ID = 28190856
API_HASH = "6b9b5309c2a211b526c6ddad6eabb521"
PHONE_NUMBER = "+989011243659"
SESSION_NAME = "my_account"

# متن پاسخ خودکار در غیاب شما (متن جدید طبق درخواست شما)
AUTO_REPLY_MESSAGE = "سلام، آنلاین نیستم. در اولین فرصت پاسخ خواهم داد."

# تعریف منطقه زمانی تهران
TEHRAN_TIMEZONE = ZoneInfo("Asia/Tehran")

# ساخت کلاینت Pyrogram
app = Client(SESSION_NAME, api_id=API_ID, api_hash=API_HASH, phone_number=PHONE_NUMBER)

# =======================================================
# بخش ۱: مدیریت فونت و ساعت زنده (Live Clock)
# =======================================================

def stylize_time(time_str: str) -> str:
    """
    تبدیل ارقام ساعت به فونت شیک Sans-Serif Bold.
    این فونت جدید به طور کامل از تمام اعداد پشتیبانی می‌کند.
    """
    conversion_map = {
        '0': '𝟬', '1': '𝟭', '2': '𝟮', '3': '𝟯', '4': '𝟰',
        '5': '𝟱', '6': '𝟲', '7': '𝟳', '8': '𝟴', '9': '𝟵',
        ':': ':'
    }
    return ''.join(conversion_map.get(char, char) for char in time_str)

async def update_name():
    """
    حلقه بی‌پایان برای به‌روزرسانی نام با ساعت زنده. بسیار مقاوم در برابر قطعی شبکه و خطاها.
    """
    first_name = "𝓎𝑒 𝒶𝓂𝒾𝓇"
    
    while True:
        try:
            # --- منطق اصلی ---
            tehran_time = datetime.now(TEHRAN_TIMEZONE)
            current_time_str = tehran_time.strftime("%H:%M")
            stylized_time_str = stylize_time(current_time_str)
            name_with_clock = f"{first_name} {stylized_time_str}"
            
            # به‌روزرسانی نام
            await app.update_profile(first_name=name_with_clock)
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ✅ Updated name to: {name_with_clock}")
        
        except FloodWait as e:
            # اگر تلگرام بگوید صبر کن
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] 🛑 Rate Limit hit. Waiting for {e.value} seconds.")
            await asyncio.sleep(e.value)
            
        except ConnectionError:
            # خطای قطع اتصال شبکه (از exception داخلی پایتون استفاده می‌شود)
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ⚠️ Connection lost. Waiting 10 seconds before next attempt.")
            await asyncio.sleep(10)
            
        except Exception as e:
            # مدیریت خطای عمومی
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ❌ Unhandled Error during name update: {e}")
            await asyncio.sleep(5)

        # --- منطق همگام‌سازی ---
        now = datetime.now()
        # منتظر می‌مانیم تا دقیقه بعدی شروع شود
        sleep_seconds = 60 - now.second
        await asyncio.sleep(sleep_seconds)

# =======================================================
# بخش ۲: پاسخ خودکار (Auto-Reply)
# =======================================================

@app.on_message(filters.private & ~filters.me)
async def auto_reply(client: Client, message):
    """
    فقط به پیام‌های خصوصی (Private Messages) که از طرف خود کاربر نیستند، پاسخ می‌دهد.
    کد این بخش کاملا درست بود و مشکلی نداشت. احتمالا چون ربات شما خاموش می‌شد، کار نمی‌کرد.
    """
    try:
        if message.from_user and not message.from_user.is_bot:
            await message.reply_text(AUTO_REPLY_MESSAGE)
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] 💬 SUCCESS: Auto-reply sent to {message.from_user.first_name} ({message.chat.id})")
    except Exception as e:
        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ❌ ERROR: Failed to send auto-reply to {message.chat.id}: {e}")

# =======================================================
# بخش ۳: تابع اصلی و اجرای همزمان (Concurrency)
# =======================================================

async def main():
    """Starts the client safely and runs the tasks."""
    # ۱. وب‌سرور را برای روشن نگه‌داشتن ربات اجرا کن
    keep_alive()
    print("✅ Keep-alive web server started.")
    print("----------------------------------------------------------------------")
    print(f"Starting Telegram Client for user: {PHONE_NUMBER}")
    
    try:
        # ۲. اتصال به تلگرام
        await app.start()
    except AuthKeyUnregistered:
        print("🔴 FATAL ERROR: Authentication Key Unregistered. Please delete the 'my_account.session' file and restart.")
        return
    except Exception as e:
        print(f"🔴 FATAL ERROR: Unhandled exception during startup: {e}")
        return

    # ۳. اجرای حلقه به‌روزرسانی نام در پس‌زمینه
    asyncio.create_task(update_name())
    print("✅ Live Clock started as a background task.")
    
    # ۴. نگه‌داشتن برنامه برای گوش دادن به پیام‌ها
    print("👂 Auto-Reply listener is active and waiting for private messages...")
    await asyncio.Event().wait()
    
    await app.stop()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nBot stopped by user (Ctrl+C). Goodbye!")

