import asyncio
from pyrogram import Client, filters
from pyrogram.errors import AuthKeyUnregistered, FloodWait # ConnectionError حذف شد
from datetime import datetime
from zoneinfo import ZoneInfo

# =======================================================
# ⚠️ تنظیمات حساب کاربری (Account Configuration)
# =======================================================

# Your credentials
API_ID = 28190856
API_HASH = "6b9b5309c2a211b526c6ddad6eabb521"
PHONE_NUMBER = "+989011243659"
SESSION_NAME = "my_account" 

# متن پاسخ خودکار در غیاب شما
AUTO_REPLY_MESSAGE = "سلام، آنلاین نیستم. پیام شما را دریافت کردم. در حال حاضر خارج از دسترس هستم، اما در اولین فرصت ممکن، پاسخ خواهم داد."

# تعریف منطقه زمانی تهران
TEHRAN_TIMEZONE = ZoneInfo("Asia/Tehran")

# ساخت کلاینت Pyrogram
app = Client(SESSION_NAME, api_id=API_ID, api_hash=API_HASH, phone_number=PHONE_NUMBER)

# =======================================================
# بخش ۱: مدیریت فونت و ساعت زنده (Live Clock)
# =======================================================

def stylize_time(time_str: str) -> str:
    """
    تبدیل ارقام ساعت به فونت شیک Math Monospace.
    """
    conversion_map = {
        '0': '𝟶', '1': '𝟷', '2': '𝟸', '3': '𝟹', '4': '𝟺',
        '5': '𝟻', '6': '𝼼', '7': '𝟽', '8': '𝟾', '9': '𝟿',
        ':': ':'
    }
    return ''.join(conversion_map.get(char, char) for char in time_str)

async def update_name():
    """
    حلقه بی‌پایان برای به‌روزرسانی نام با ساعت زنده. بسیار مقاوم در برابر قطعی شبکه و خطاها.
    """
    first_name = "𝓎𝑒 𝒶𝓂𝒾𝓇"
    
    while True:
        try:
            # --- منطق اصلی ---
            tehran_time = datetime.now(TEHRAN_TIMEZONE)
            current_time_str = tehran_time.strftime("%H:%M")
            stylized_time_str = stylize_time(current_time_str)
            name_with_clock = f"{first_name} {stylized_time_str}"
            
            # به‌روزرسانی نام
            await app.update_profile(first_name=name_with_clock)
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ✅ Updated name to: {name_with_clock}")
        
        except FloodWait as e:
            # اگر تلگرام بگوید صبر کن
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] 🛑 Rate Limit hit. Waiting for {e.value} seconds.")
            await asyncio.sleep(e.value)
            
        except ConnectionError:
            # خطای قطع اتصال شبکه (از exception داخلی پایتون استفاده می‌شود)
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ⚠️ Connection lost. Waiting 10 seconds before next attempt.")
            # Pyrogram به صورت داخلی سعی در اتصال مجدد می کند، ما فقط مکث می کنیم.
            await asyncio.sleep(10)
            
        except Exception as e:
            # مدیریت خطای عمومی (مثل Peer ID invalid یا هر چیز ناشناخته دیگر)
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ❌ Unhandled Error during name update. Attempting to recover: {e}")
            # مکث 5 ثانیه ای و ادامه حلقه برای تلاش مجدد
            await asyncio.sleep(5) 

        # --- منطق همگام‌سازی (حتی در صورت خطا این بخش اجرا می‌شود) ---
        now = datetime.now()
        seconds_into_minute = now.second + now.microsecond / 1_000_000
        sleep_seconds = 60 - seconds_into_minute
        
        if sleep_seconds < 0.5:
             sleep_seconds += 60

        await asyncio.sleep(sleep_seconds)

# =======================================================
# بخش ۲: پاسخ خودکار (Auto-Reply)
# =======================================================

@app.on_message(filters.private & ~filters.me)
async def auto_reply(client: Client, message):
    """
    فقط به پیام‌های خصوصی (Private Messages) که از طرف خود کاربر نیستند، پاسخ می‌دهد.
    """
    try:
        if message.from_user and not message.from_user.is_bot:
            await message.reply_text(AUTO_REPLY_MESSAGE)
            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] 💬 SUCCESS: Auto-reply sent to {message.from_user.first_name} ({message.chat.id})")
    except Exception as e:
        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ❌ ERROR: Failed to send auto-reply to {message.chat.id}: {e}")

# =======================================================
# بخش ۳: تابع اصلی و اجرای همزمان (Concurrency)
# =======================================================

async def main():
    """Starts the client safely and runs the tasks."""
    print("----------------------------------------------------------------------")
    print(f"Starting Telegram Client for user: {PHONE_NUMBER}")
    
    try:
        # اتصال اولیه
        await app.start()
    except AuthKeyUnregistered:
        print("🔴 FATAL ERROR: Authentication Key Unregistered. Please delete the 'my_account.session' file and restart the bot to re-authenticate.")
        return
    except ConnectionError:
        # خطای اتصال: در این بلوک از ConnectionError داخلی پایتون استفاده می شود
        print("🔴 FATAL ERROR: Initial connection failed. Check your internet connection and Telegram API settings.")
        return
    except Exception as e:
        print(f"🔴 FATAL ERROR: Unhandled exception during startup: {e}")
        return

    # 2. اجرای حلقه به‌روزرسانی نام در پس‌زمینه
    asyncio.create_task(update_name())
    print("✅ Live Clock started as a background task.")
    
    # 3. نگه‌داشتن برنامه
    print("👂 Auto-Reply listener is active and waiting for private messages...")
    await asyncio.Event().wait()
    
    await app.stop()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nBot stopped by user (Ctrl+C). Goodbye!")
    except Exception as e:
        print(f"\n\nAn unexpected error occurred in main execution: {e}")
