import asyncio
import os
from pyrogram import Client, filters
from pyrogram.errors import AuthKeyUnregistered, FloodWait, RPCError
from datetime import datetime
from zoneinfo import ZoneInfo
import logging
from flask import Flask, request, render_template_string
import requests # برای مکانیزم ضد خواب
from waitress import serve # برای اجرای ایمن Flask در سرورهای ابری

# تنظیمات اولیه لاگینگ
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# =======================================================
# ⚠️ تنظیمات حساب کاربری و حالت (Global State)
# =======================================================

# توصیه می شود این مقادیر را به عنوان Secrets در Replit/Render تنظیم کنید.
API_ID = int(os.environ.get("API_ID", 28190856))
API_HASH = os.environ.get("API_HASH", "6b9b5309c2a211b526c6ddad6eabb521")
SESSION_NAME = "my_account_web"

# NEW: از شماره تلفن و پسورد (اختیاری) در Secrets برای لاگین اولیه استفاده کنید.
# شماره تلفن شما به عنوان مقدار پیش‌فرض در کد قرار داده شد.
PHONE_NUMBER = os.environ.get("PHONE_NUMBER", "+989011243659")
# رمز دومرحله‌ای شما به صورت مستقیم در کد قرار داده شد. (توصیه: برای امنیت بیشتر، آن را در Secrets بگذارید)
BOT_PASSWORD = os.environ.get("BOT_PASSWORD", "Amirpitmax$1388$")


# متن پاسخ خودکار در غیاب شما
AUTO_REPLY_MESSAGE = "سلام، آنلاین نیستم. پیام شما را دریافت کردم. در حال حاضر خارج از دسترس هستم، اما در اولین فرصت ممکن، پاسخ خواهم داد."

# تعریف منطقه زمانی تهران
TEHRAN_TIMEZONE = ZoneInfo("Asia/Tehran")

# متغیرهای حالت سراسری
app_flask = Flask(__name__)
app_client = None 
bot_running_event = asyncio.Event()

# =======================================================
# بخش ۱: مدیریت فونت و ساعت زنده (Live Clock)
# =======================================================

def stylize_time(time_str: str) -> str:
    """
    تبدیل ارقام ساعت به فونت شیک Fullwidth (تمام عرض) برای سازگاری بیشتر با دستگاه‌ها.
    """
    conversion_map = {
        '0': '０', '1': '１', '2': '２', '3': '３', '4': '４',
        '5': '５', '6': '６', '7': '７', '8': '８', '9': '９',
        ':': '：' # استفاده از کولون تمام عرض برای سازگاری
    }
    return ''.join(conversion_map.get(char, char) for char in time_str)

async def update_name():
    """حلقه بی‌پایان برای به‌روزرسانی نام با ساعت زنده. بسیار مقاوم در برابر قطعی شبکه و خطاها."""
    first_name = "𝓎𝑒 𝒶𝓂𝒾𝓇"
    
    global app_client
    if app_client is None:
        logger.error("❌ update_name called but app_client is not initialized.")
        return

    while True:
        # --- منطق همگام‌سازی (اولین کار در حلقه، برای اطمینان از دقت) ---
        now = datetime.now()
        seconds_into_minute = now.second + now.microsecond / 1_000_000
        sleep_seconds = 60 - seconds_into_minute
        
        if sleep_seconds < 0.5:
            sleep_seconds += 60
        
        await asyncio.sleep(sleep_seconds)
        
        try:
            # --- منطق اصلی به‌روزرسانی ---
            tehran_time = datetime.now(TEHRAN_TIMEZONE)
            current_time_str = tehran_time.strftime("%H:%M")
            stylized_time_str = stylize_time(current_time_str)
            name_with_clock = f"{first_name} {stylized_time_str}"
            
            # به‌روزرسانی نام
            await app_client.update_profile(first_name=name_with_clock)
            logger.info(f"✅ Live Clock: Updated name to: {name_with_clock}")
        
        except FloodWait as e:
            logger.warning(f"🛑 Live Clock: Rate Limit hit. Waiting for {e.value} seconds.")
            await asyncio.sleep(e.value)
            
        except (RPCError, asyncio.TimeoutError):
            logger.error("⚠️ Live Clock: Connection error or API call timed out. Waiting 10 seconds before next attempt.")
            await asyncio.sleep(10)
            
        except Exception as e:
            logger.error(f"❌ Live Clock: Unhandled Error during name update. Attempting to recover: {e}")
            await asyncio.sleep(5)

# =======================================================
# بخش ۲: پاسخ خودکار (Auto-Reply)
# =======================================================

def register_handlers(client: Client):
    @client.on_message(filters.private & ~filters.me)
    async def auto_reply(client: Client, message):
        """فقط به پیام‌های خصوصی که از طرف خود کاربر نیستند، پاسخ می‌دهد."""
        try:
            if message.from_user and not message.from_user.is_bot:
                await message.reply_text(AUTO_REPLY_MESSAGE)
                logger.info(f"💬 Auto-Reply: SUCCESS sent to {message.from_user.first_name}")
        except Exception as e:
            logger.error(f"❌ Auto-Reply: Failed to send to {message.chat.id}: {e}")

# =======================================================
# بخش ۳: مکانیزم ضد خواب (Anti-Sleep for Render/Replit)
# =======================================================

async def keep_alive(anti_sleep_url: str):
    """
    هر 5 دقیقه یک بار به آدرس URL خود پروژه درخواست می فرستد تا از خوابیدن سرور جلوگیری کند.
    """
    if anti_sleep_url == "http://127.0.0.1:5000":
        logger.warning("❌ ANTI-SLEEP WARNING: The URL is set to localhost. You MUST set the 'RENDER_EXTERNAL_URL' Secret in Replit with your public URL (e.g., https://selfprofile-3.amirpitmax3.repl.co) for 24/7 function.")
    else:
        logger.info(f"🔋 Anti-Sleep activated. Pinging URL: {anti_sleep_url} every 5 minutes.")

    while True:
        await asyncio.sleep(300) # 5 minutes
        try:
            if anti_sleep_url != "http://127.0.0.1:5000":
                # از یک timeout کوتاه استفاده می کنیم تا منتظر پاسخ کامل نمانیم
                requests.get(anti_sleep_url, timeout=10)
                logger.debug("✨ Keep Alive: Ping successful.")
        except Exception as e:
            logger.warning(f"❌ Keep Alive: Failed to ping URL {anti_sleep_url}. Error: {e}")

# =======================================================
# بخش ۴: رابط وب (Flask Web Interface)
# =======================================================

# قالب HTML ساده و زیبا برای نمایش وضعیت و راهنمای لاگین با شماره تلفن
WEB_FORM_HTML = """
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>وضعیت سلف‌بات Clock</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');
        body { font-family: 'Vazirmatn', sans-serif; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="max-w-md w-full bg-white p-8 rounded-xl shadow-2xl border border-blue-200">
        <h1 class="text-3xl font-bold text-center text-blue-700 mb-6">⏰ وضعیت ربات ساعت زنده</h1>
        <p class="text-gray-600 text-center mb-4">این صفحه برای فعال نگه داشتن ربات در Replit لازم است.</p>
        
        {% if status %}
            <div class="p-4 mb-6 rounded-lg font-medium text-center 
            {% if 'فعال شد' in status %} bg-green-100 text-green-700 
            {% elif 'منتظر' in status %} bg-yellow-100 text-yellow-700
            {% else %} bg-red-100 text-red-700 
            {% endif %}">
                وضعیت: {{ status }}
            </div>
        {% endif %}

        <div class="text-sm p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
            <h2 class="font-bold text-yellow-800 mb-2">نحوه لاگین با شماره تلفن:</h2>
            <ol class="list-decimal list-inside text-yellow-700 space-y-1">
                <li>ربات را در Replit **اجرا (Run)** کنید.</li>
                <li>در **کنسول (Console)** ریپلیت، شماره تلفن (با کد کشور) و سپس کد تایید تلگرام را وارد کنید.</li>
                <li>پس از ورود موفقیت‌آمیز، فایل سشن ذخیره می‌شود و ربات شروع به کار می‌کند.</li>
            </ol>
            <p class="mt-3 font-semibold text-yellow-800">⚠️ برای اجرای ۲۴ ساعته، Session String به محیط وبسایت نیاز نیست، اما حتماً متغیر `RENDER_EXTERNAL_URL` را در Secrets ریپلیت با آدرس عمومی پروژه پر کنید.</p>
        </div>
        
        <p class="text-xs text-gray-400 text-center mt-6">
            <a href="https://replit.com/@amirpitmax3/selfprofile-3" target="_blank" class="hover:underline">پروژه Replit شما</a>
        </p>
    </div>
</body>
</html>
"""

# مسیر اصلی وب‌سایت
@app_flask.route('/', methods=['GET'])
def index():
    status = "ربات هنوز شروع نشده است (چک کردن کنسول برای لاگین)."
    if bot_running_event.is_set():
        status = "فعال شد! ساعت زنده و پاسخ خودکار در حال اجرا هستند. (لاگین موفق)"
    elif app_client and not bot_running_event.is_set():
        status = "منتظر... در حال تلاش برای اتصال/لاگین در کنسول."
        
    return render_template_string(WEB_FORM_HTML, status=status)

# =======================================================
# بخش ۵: اجرای هسته (Core Execution)
# =======================================================

async def start_pyrogram_client():
    """
    ربات Pyrogram را شروع می کند. اگر فایل سشن وجود نداشته باشد، به طور خودکار
    در کنسول منتظر ورود شماره تلفن، کد تایید و پسورد (در صورت وجود 2FA) می ماند.
    """
    global app_client
    
    # 1. مقداردهی اولیه کلاینت
    try:
        app_client = Client(
            name=SESSION_NAME, 
            api_id=API_ID, 
            api_hash=API_HASH,
            # استفاده از پارامترهای جدید برای لاگین با شماره تلفن
            phone_number=PHONE_NUMBER,
            password=BOT_PASSWORD,
            in_memory=False # مطمئن می شویم که سشن در فایل ذخیره شود
        )
        logger.info("Initializing Pyrogram Client...")

        # 2. اتصال و لاگین (در صورت نیاز به صورت تعاملی در کنسول)
        logger.info(f"Connecting to Telegram with phone number: {PHONE_NUMBER}. If the session file is missing, Pyrogram will prompt for OTP and Password in the Replit Console.")
        await app_client.start()
        logger.info("✅ Client successfully connected and authenticated! Session file saved.")
        
    except AuthKeyUnregistered:
        logger.critical("🔴 FATAL ERROR: Invalid credentials or session. Please check PHONE_NUMBER and BOT_PASSWORD.")
        app_client = None
        return
    except Exception as e:
        # این خطا شامل درخواست‌های تعاملی Pyrogram برای OTP/Password در کنسول خواهد بود
        logger.critical(f"🔴 FATAL ERROR during client start (Please check Replit Console for interactive login prompts): {e}")
        app_client = None
        return

    # 3. ثبت هندلرها
    register_handlers(app_client)
    logger.info("✅ Auto-Reply handler registered.")

    # 4. اجرای ساعت و ضد خواب
    asyncio.create_task(update_name())
    logger.info("✅ Live Clock started as a background task.")

    # Anti-Sleep: استفاده از متغیر محیطی که آدرس عمومی پروژه را نگه می‌دارد.
    anti_sleep_url = os.environ.get('RENDER_EXTERNAL_URL') or "http://127.0.0.1:5000"
    asyncio.create_task(keep_alive(anti_sleep_url))

    bot_running_event.set() # تنظیم فلگ برای نشان دادن اجرای ربات


def run_pyrogram_and_flask():
    """شروع وظایف Pyrogram و Flask در حلقه async واحد."""
    port = int(os.environ.get("PORT", 5000))
    host = '0.0.0.0' 
    
    # Pyrogram client must be started first to allow interactive login in the console
    loop = asyncio.get_event_loop()
    loop.run_until_complete(start_pyrogram_client())
    
    # Only start the web server if Pyrogram client successfully started
    if app_client:
        logger.info(f"🌐 Flask Web Server starting on {host}:{port}")
        # از تابع serve کتابخانه Waitress برای اجرای Flask در یک Thread جداگانه استفاده می کنیم
        loop.run_in_executor(None, serve, app_flask, host=host, port=port)
    else:
         logger.critical("Web server not started because Pyrogram client failed to initialize or connect.")
        
    try:
        loop.run_forever()
    except KeyboardInterrupt:
        logger.info("\nServer and Bot stopped by user (Ctrl+C).")
    finally:
        # کلاینت فقط در صورت وجود و فعال بودن متوقف می شود
        if app_client:
            loop.run_until_complete(app_client.stop())
        logger.info("Cleanup complete. Goodbye!")

if __name__ == "__main__":
    # اجرای Pyrogram (برای لاگین) و Flask (برای Keep-Alive)
    run_pyrogram_and_flask()
